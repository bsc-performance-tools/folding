\chapter{Quick user guide}\label{cha:QuickUserGuide}

The \FOLDING framework enables depicting the evolution of the performance counters as well as the source code locations by combining information from instrumented and sampled tracefiles.
Before continuing this chapter, please make sure that you have generated a tracefile with both sampling and instrumented information.
For further references on how to obtain a tracefile ready to apply folding, see Appendix \ref{cha:GetATrace}.

This chapter is divided different sections, each providing insight on how to execute the framework on different types of tracefiles (including MPI, OpenMP, OmpSs and manually instrumented).a
The chapter ends with information on how to visualize the results from the framework on Section~\ref{sec:Q_visualization_results}.

\section{Applying the folding}

\textbf{Attention:} No matter the code that is being instrumented (MPI, OpenMP, OmpSs, or even using manual instrumentation), it is imperative that the enclosing events have performance counters associated.
If this requirement is not fulfilled, the folding process will abort.
For a proper configuration on the instrumentation package to ensure that performance counters are emitted, refer to \TRACE user guide.

\subsection{On MPI tracefiles without any further instrumentation}

In event the user does not know the application behavior of the application, or just gathered a tracefile with MPI information, it is strongly suggested to use the clustering tool (\texttt{BurstClustering}) from the ClusteringSuite\footnote{The ClusteringSuite can be downloaded from the BSC tools web page} to automatically identify compute regions.
Notice that variability in obtained clusters may affect the folding results, thus try to tune the clustering tool so as to generate clusters the more compact as possible.

To launch the folding on a clustered MPI tracefile named \texttt{mpi\_app.clustered.prv}, just issue the following command:
\begin{verbatim}
	${FOLDING_HOME}/bin/folding mpi_app.clustered.prv "Cluster ID"
\end{verbatim}

\subsection{On OpenMP tracefiles}

\TRACE instruments OpenMP outlined routines\footnote{Several compilers, when face a \texttt{\#pragma omp parallel} region in the source code, wrap the contents of the region in an additional routine called outlined routine.}, therefore it is possible to apply the folding on tracefiles generated from OpenMP applications.
To apply the folding on tracefiles generated from tracefiles, consider an OpenMP tracefile named \texttt{omp\_app.prv} and issue the following command:
\begin{verbatim}
	${FOLDING_HOME}/bin/folding omp_app.prv "Parallel function"
\end{verbatim}

\subsection{On OmpSs tracefiles}

The OmpSs instrumentation package relies on \TRACE to generate tracefiles.
In addition to the regular instrumentation, OmpSs instrumentation plugin emits additional information into the tracefile reporting activities such when a taskified routine starts and stops.
The folding mechanism can be applied to provide insight on these taskified routines.
To do so, consider tracefile obtained through OmpSs is named \texttt{ompss\_app.prv}, just issue the following command:
\begin{verbatim}
	${FOLDING_HOME}/bin/folding ompss_app.prv "User Function Name"
\end{verbatim}

\subsection{Applying folding on tracefiles with manually added instrumentation}

There exists the chance for the user to manually delimit the region of code on which the folding should apply.
In this case, the user needs to insert events into the tracefile by either using calls to \TRACE as \texttt{Extrae\_user\_function} or \texttt{Extrae\_eventandcounters}.

In case the user takes benefit of the \texttt{Extrae\_user\_function}, the folding can take advantage of the unique event type identifier associated to user routines.
To apply the folding mechanism on a tracefile named \texttt{user\_functions\_app.prv} with routine events, execute the following commands:
\begin{verbatim}
	${FOLDING_HOME}/bin/folding user_functions_app.prv "User Function"
\end{verbatim}

On the other hand, if the user emits additional events using \texttt{Extrae\_eventandcounters}, it is appropriate to use a unique event type for all the instrumented regions but using a different event value for every different region.
Consider that the tracefile \texttt{own\_events.prv} contains an event type / value pair such as < 1000, \textit{loc} > where \textit{loc} determines different location points within the application.
In order to apply the folding to this tracefile, the user shall invoke the folding such as:
\begin{verbatim}
	${FOLDING_HOME}/bin/folding own_events.prv 1000
\end{verbatim}

\section{Outputs generated}\label{sec:Q_visualization_results}

The folding mechanism generates two types of output inside a directory named as the tracefile given (without the \texttt{.prv} suffix).
A set of gnuplot files where each of these represents the evolution of the performance counters within the region and a \PARAVER tracefile with synthetic information derived from the folding mechanism.
With respect to the gnuplot files, the folding mechanism generates as many files as the combination of analyzed regions (clusters, OpenMP outlined routines, taskified OmpSs routines, or manually delimited regions) and the counters gathered during the application execution.
To explore the gnuplot files, the user may invoke a visualizer named \texttt{wxfolding-viewer}, by invoking it from the newly created directory such as:
\begin{verbatim}
	${FOLDING_HOME}/bin/wxfolding-viewer *.wxfolding
\end{verbatim}

The user can also inspect the gnuplot files exploring the contents of the directory by using a call to \texttt{ls \*.gnuplot}.
The name of the gnuplot files identifies the region and the performance counter analysed, and the user only needs to call gnuplot such as:
\begin{verbatim}
	gnuplot -persist mpi_app.clustered..codeblocks.fused.any.any.any.Cluster_1.Group_0.PAPI_TOT_INS.gnuplot
\end{verbatim}
The example given, for instance, would show the evolution of the graduated instructions of the region named Cluster 1.


